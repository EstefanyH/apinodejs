"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHttpApiEvent = exports.isHttpEvent = exports.pathToParam = exports.httpEventToParameters = exports.formatResponses = void 0;
const helperFunctions_1 = require("./helperFunctions");
const formatResponses = (responseData) => {
    if (!responseData) {
        // could throw error
        return { 200: { description: '200 response' } };
    }
    const formatted = {};
    Object.entries(responseData).forEach(([statusCode, responseDetails]) => {
        if (typeof responseDetails == 'string') {
            formatted[statusCode] = {
                description: responseDetails,
            };
            return;
        }
        const response = { description: responseDetails.description || `${statusCode} response` };
        if (responseDetails.bodyType) {
            response.schema = { $ref: `#/definitions/${responseDetails.bodyType}` };
        }
        formatted[statusCode] = response;
    });
    return formatted;
};
exports.formatResponses = formatResponses;
// httpEventToSecurity = (http: EitherHttpEvent) => {
//   // TODO - add security sections
//   return undefined
// }
// The arg is actually type `HttpEvent | HttpApiEvent`, but we only use it if it has httpEvent props (or shared props),
//  so we can lie to the compiler to make typing simpler
const httpEventToParameters = (httpEvent) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const parameters = [];
    if (httpEvent.bodyType) {
        parameters.push({
            in: 'body',
            name: 'body',
            description: 'Body required in the request',
            required: true,
            schema: { $ref: `#/definitions/${httpEvent.bodyType}` },
        });
    }
    const rawPathParams = (_b = (_a = httpEvent.request) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b.paths;
    const match = httpEvent.path.match(/[^{}]+(?=})/g);
    let pathParameters = match !== null && match !== void 0 ? match : [];
    if (rawPathParams) {
        Object.entries(rawPathParams !== null && rawPathParams !== void 0 ? rawPathParams : {}).forEach(([param, paramInfo]) => {
            parameters.push((0, exports.pathToParam)(param, paramInfo));
            pathParameters = (0, helperFunctions_1.removeStringFromArray)(pathParameters, param);
        });
    }
    // If no match, will just be [] anyway
    pathParameters.forEach((param) => parameters.push((0, exports.pathToParam)(param)));
    if (httpEvent.headerParameters || ((_d = (_c = httpEvent.request) === null || _c === void 0 ? void 0 : _c.parameters) === null || _d === void 0 ? void 0 : _d.headers)) {
        // If no headerParameters are provided, try to use the builtin headers
        const rawHeaderParams = (_e = httpEvent.headerParameters) !== null && _e !== void 0 ? _e : Object.entries(httpEvent.request.parameters.headers).reduce((acc, [name, required]) => (Object.assign(Object.assign({}, acc), { [name]: { required, type: 'string' } })), {});
        Object.entries(rawHeaderParams).forEach(([param, data]) => {
            var _a, _b;
            parameters.push({
                in: 'header',
                name: param,
                required: (_a = data.required) !== null && _a !== void 0 ? _a : false,
                type: (_b = data.type) !== null && _b !== void 0 ? _b : 'string',
                description: data.description,
            });
        });
    }
    if (httpEvent.queryStringParameters || ((_g = (_f = httpEvent.request) === null || _f === void 0 ? void 0 : _f.parameters) === null || _g === void 0 ? void 0 : _g.querystrings)) {
        // If no queryStringParameters are provided, try to use the builtin query strings
        const rawQueryParams = (_h = httpEvent.queryStringParameters) !== null && _h !== void 0 ? _h : Object.entries(httpEvent.request.parameters.querystrings).reduce((acc, [name, required]) => (Object.assign(Object.assign({}, acc), { [name]: { required, type: 'string' } })), {});
        Object.entries(rawQueryParams).forEach(([param, data]) => {
            var _a, _b;
            parameters.push(Object.assign({ in: 'query', name: param, type: (_a = data.type) !== null && _a !== void 0 ? _a : 'string', description: data.description, required: (_b = data.required) !== null && _b !== void 0 ? _b : false }, (data.type === 'array'
                ? {
                    items: { type: data.arrayItemsType },
                    collectionFormat: 'multi',
                }
                : {})));
        });
    }
    return parameters;
};
exports.httpEventToParameters = httpEventToParameters;
const pathToParam = (pathParam, paramInfoOrRequired) => {
    var _a;
    const isObj = typeof paramInfoOrRequired === 'object';
    const required = (_a = (isObj ? paramInfoOrRequired.required : paramInfoOrRequired)) !== null && _a !== void 0 ? _a : true;
    return {
        name: pathParam,
        in: 'path',
        required,
        description: isObj ? paramInfoOrRequired.description : undefined,
        type: 'string',
    };
};
exports.pathToParam = pathToParam;
const isHttpEvent = (event) => {
    return event.http !== undefined;
};
exports.isHttpEvent = isHttpEvent;
const isHttpApiEvent = (event) => {
    return event.httpApi !== undefined;
};
exports.isHttpApiEvent = isHttpApiEvent;
