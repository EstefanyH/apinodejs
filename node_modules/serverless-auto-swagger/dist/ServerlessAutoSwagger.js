'use strict';
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const glob_1 = require("glob");
const typeconv_1 = require("typeconv");
const helperFunctions_1 = require("./helperFunctions");
const functions_1 = require("./resources/functions");
const customPropertiesSchema = require("./schemas/custom-properties.schema.json");
const functionEventPropertiesSchema = require("./schemas/function-event-properties.schema.json");
const converters_1 = require("./converters");
class ServerlessAutoSwagger {
    // IO is only injected in Serverless v3.0.0 (can experiment with `import { writeText, log, progress } from '@serverless/utils/log'; in a future PR)
    constructor(serverless, options, io) {
        var _a;
        this.swagger = (0, helperFunctions_1.generateEmptySwagger)();
        this.enrichServerlessSchema = () => {
            var _a, _b, _c;
            // TODO: Test custom properties configuration
            (_a = this.serverless.configSchemaHandler) === null || _a === void 0 ? void 0 : _a.defineCustomProperties(customPropertiesSchema);
            (_b = this.serverless.configSchemaHandler) === null || _b === void 0 ? void 0 : _b.defineFunctionEventProperties('aws', 'http', functionEventPropertiesSchema);
            (_c = this.serverless.configSchemaHandler) === null || _c === void 0 ? void 0 : _c.defineFunctionEventProperties('aws', 'httpApi', functionEventPropertiesSchema);
        };
        this.preDeploy = async () => {
            var _a;
            const stage = this.serverless.service.provider.stage;
            const excludedStages = this.autoSwaggerCustomConfig.excludeStages;
            if (excludedStages && excludedStages.includes(stage)) {
                this.log.notice(`Swagger lambdas will not be deployed for stage [${stage}], as it has been marked for exclusion.`);
                return;
            }
            const generateSwaggerOnDeploy = (_a = this.autoSwaggerCustomConfig.generateSwaggerOnDeploy) !== null && _a !== void 0 ? _a : true;
            if (generateSwaggerOnDeploy)
                await this.generateSwagger();
            this.addEndpointsAndLambda();
        };
        this.generateSwagger = async () => {
            await this.gatherTypes();
            this.gatherSwaggerOverrides();
            this.generateSecurity();
            this.generatePaths();
            this.log.notice('Creating Swagger file...');
            const resourcesPath = await this.prepareResourceFolder();
            await this.writeSwaggerFile(resourcesPath);
        };
        /** Updates this.swagger with serverless custom.autoswagger overrides */
        this.gatherSwaggerOverrides = () => {
            var _a;
            const autoswagger = this.autoSwaggerCustomConfig;
            if (autoswagger.basePath)
                this.swagger.basePath = autoswagger.basePath;
            if (autoswagger.host)
                this.swagger.host = autoswagger.host;
            if (autoswagger.schemes)
                this.swagger.schemes = autoswagger.schemes;
            if (autoswagger.title)
                this.swagger.info.title = autoswagger.title;
            if (autoswagger.description)
                this.swagger.info.description = autoswagger.description;
            if (autoswagger.version)
                this.swagger.info.version = autoswagger.version;
            // There must be at least one or this `if` will be false
            if ((_a = autoswagger.swaggerFiles) === null || _a === void 0 ? void 0 : _a.length)
                this.gatherSwaggerFiles(autoswagger.swaggerFiles);
        };
        /** Updates this.swagger with swagger file overrides */
        this.gatherSwaggerFiles = (swaggerFiles) => {
            swaggerFiles.forEach((filepath) => {
                const fileData = (0, fs_extra_1.readFileSync)(filepath, 'utf8');
                const jsonData = JSON.parse(fileData);
                const { paths = {}, definitions = {} } = jsonData, swagger = __rest(jsonData, ["paths", "definitions"]);
                this.swagger = Object.assign(Object.assign(Object.assign({}, this.swagger), swagger), { paths: Object.assign(Object.assign({}, this.swagger.paths), paths), definitions: Object.assign(Object.assign({}, this.swagger.definitions), definitions) });
            });
        };
        this.gatherTypes = async () => {
            // get the details from the package.json? for info
            const service = this.serverless.service.service;
            if (typeof service === 'string')
                this.swagger.info.title = service;
            else
                this.swagger.info.title = service.name;
            const reader = (0, typeconv_1.getTypeScriptReader)();
            const writer = (0, typeconv_1.getOpenApiWriter)({
                format: 'json',
                title: this.swagger.info.title,
                version: 'v1',
                schemaVersion: '2.0',
            });
            const { convert } = (0, typeconv_1.makeConverter)(reader, writer);
            try {
                const typeLocationOverride = this.autoSwaggerCustomConfig.typefiles;
                const typesFile = typeLocationOverride || ['./src/types/api-types.d.ts'];
                await Promise.all(typesFile
                    .reduce((files, pattern) => {
                    const newFiles = glob_1.glob.sync(pattern);
                    return [...files, ...newFiles];
                }, [])
                    .map(async (filepath) => {
                    try {
                        const fileData = (0, fs_extra_1.readFileSync)(filepath, 'utf8');
                        const { data } = await convert({ data: fileData });
                        // change the #/components/schema to #/definitions
                        const definitionsData = data.replace(/\/components\/schemas/g, '/definitions');
                        const definitions = JSON.parse(definitionsData).components.schemas;
                        // TODO: Handle `anyOf` in swagger configs
                        this.swagger.definitions = Object.assign(Object.assign({}, this.swagger.definitions), definitions);
                    }
                    catch (error) {
                        this.log.error(`Couldn't read types from file: ${filepath}`);
                        return;
                    }
                }));
                // TODO change this to store these as temporary and only include definitions used elsewhere.
            }
            catch (error) {
                this.log.error(`Unable to get types: ${error}`);
            }
        };
        this.generateSecurity = () => {
            const apiKeyHeaders = this.autoSwaggerCustomConfig.apiKeyHeaders;
            if (apiKeyHeaders === null || apiKeyHeaders === void 0 ? void 0 : apiKeyHeaders.length) {
                const securityDefinitions = {};
                apiKeyHeaders.forEach((indexName) => {
                    securityDefinitions[indexName] = {
                        type: 'apiKey',
                        name: indexName,
                        in: 'header',
                    };
                });
                this.swagger = Object.assign(Object.assign({}, this.swagger), { securityDefinitions });
            }
            // If no apiKeyHeaders are specified, we don't want to override any existing `securityDefinitions`
            //  that may be defined in a custom swagger json
        };
        this.addEndpointsAndLambda = () => {
            this.serverless.service.functions = Object.assign(Object.assign({}, this.serverless.service.functions), (0, functions_1.default)(this.serverless));
        };
        this.addSwaggerPath = (functionName, http) => {
            var _a, _b, _c, _d, _e;
            var _f;
            if (typeof http === 'string') {
                // TODO they're using the shorthand - parse that into object.
                //  You'll also have to remove the `typeof http !== 'string'` check from the function calling this one
                return;
            }
            let path = http.path;
            if (path[0] !== '/')
                path = `/${path}`;
            (_a = (_f = this.swagger.paths)[path]) !== null && _a !== void 0 ? _a : (_f[path] = {});
            const method = http.method.toLowerCase();
            this.swagger.paths[path][method] = {
                summary: http.summary || functionName,
                description: (_b = http.description) !== null && _b !== void 0 ? _b : '',
                tags: http.swaggerTags,
                operationId: http.operationId || `${functionName}.${method}.${http.path}`,
                consumes: (_c = http.consumes) !== null && _c !== void 0 ? _c : ['application/json'],
                produces: (_d = http.produces) !== null && _d !== void 0 ? _d : ['application/json'],
                security: http.security,
                // This is actually type `HttpEvent | HttpApiEvent`, but we can lie since only HttpEvent params (or shared params) are used
                parameters: (0, converters_1.httpEventToParameters)(http),
                responses: (0, converters_1.formatResponses)((_e = http.responseData) !== null && _e !== void 0 ? _e : http.responses),
            };
            const apiKeyHeaders = this.autoSwaggerCustomConfig.apiKeyHeaders;
            const security = [];
            if (apiKeyHeaders === null || apiKeyHeaders === void 0 ? void 0 : apiKeyHeaders.length) {
                security.push(apiKeyHeaders.reduce((acc, indexName) => (Object.assign(Object.assign({}, acc), { [indexName]: [] })), {}));
            }
            if (security.length) {
                this.swagger.paths[path][method].security = security;
            }
        };
        this.generatePaths = () => {
            var _a;
            const functions = (_a = this.serverless.service.functions) !== null && _a !== void 0 ? _a : {};
            Object.entries(functions).forEach(([functionName, config]) => {
                var _a;
                const events = (_a = config.events) !== null && _a !== void 0 ? _a : [];
                events.forEach((event) => {
                    if ((0, converters_1.isHttpEvent)(event) && !event.http.exclude) {
                        this.addSwaggerPath(functionName, event.http);
                    }
                    else if ((0, converters_1.isHttpApiEvent)(event) && !event.httpApi.exclude) {
                        this.addSwaggerPath(functionName, event.httpApi);
                    }
                });
            });
        };
        this.serverless = serverless;
        this.autoSwaggerCustomConfig = ((_a = this.serverless.service.custom) === null || _a === void 0 ? void 0 : _a.autoswagger) || {};
        this.options = options;
        this.log = this.setupLogging(io);
        this.commands = this.getCustomCommands();
        this.hooks = this.getCustomLifecycleHooks();
        this.enrichServerlessSchema();
    }
    getCustomLifecycleHooks() {
        return {
            'generate-swagger:generateSwagger': this.generateSwagger,
            'before:offline:start:init': this.preDeploy,
            'before:package:cleanup': this.preDeploy,
        };
    }
    getCustomCommands() {
        return {
            'generate-swagger': {
                usage: 'Generates Swagger for your API',
                lifecycleEvents: ['generateSwagger'],
            },
        };
    }
    setupLogging(io) {
        var _a, _b;
        if (io === null || io === void 0 ? void 0 : io.log)
            return io.log;
        else
            return {
                notice: (_b = (_a = this.serverless.cli) === null || _a === void 0 ? void 0 : _a.log) !== null && _b !== void 0 ? _b : console.log,
                error: console.error,
            };
    }
    async prepareResourceFolder() {
        // TODO enable user to specify swagger file path. also needs to update the swagger json endpoint.
        const packagePath = (0, path_1.dirname)(require.resolve('serverless-auto-swagger/package.json'));
        const resourcesPath = `${packagePath}/dist/resources`;
        await (0, fs_extra_1.copy)(resourcesPath, './swagger');
        return resourcesPath;
    }
    async writeSwaggerFile(resourcesPath) {
        if (this.isPythonRuntime()) {
            await this.writePythonSwaggerFile();
        }
        else {
            await this.writeJSSwaggerFile(resourcesPath);
        }
    }
    isPythonRuntime() {
        var _a;
        return (_a = this.serverless.service.provider.runtime) === null || _a === void 0 ? void 0 : _a.includes('python');
    }
    async writePythonSwaggerFile() {
        const swaggerStr = JSON.stringify(this.swagger, null, 2)
            .replace(/true/g, 'True')
            .replace(/false/g, 'False')
            .replace(/null/g, 'None');
        let swaggerPythonString = `# this file was generated by serverless-auto-swagger`;
        swaggerPythonString += `\ndocs = ${swaggerStr}`;
        await (0, helperFunctions_1.writeFile)('./swagger/swagger.py', swaggerPythonString);
    }
    async writeJSSwaggerFile(resourcesPath) {
        await (0, fs_extra_1.copy)(resourcesPath, './swagger', {
            filter: (src) => src.slice(-2) === 'js',
        });
        const swaggerJavaScriptString = `// this file was generated by serverless-auto-swagger
            module.exports = ${JSON.stringify(this.swagger, null, 2)};`;
        await (0, helperFunctions_1.writeFile)('./swagger/swagger.js', swaggerJavaScriptString);
    }
}
exports.default = ServerlessAutoSwagger;
